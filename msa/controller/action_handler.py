"""Action handler for the multi-step agent controller."""

import logging
from typing import Any

from langchain.output_parsers import PydanticOutputParser
from langchain_core.utils.json import parse_json_markdown

from msa.controller.models import ActionSelection
from msa.tools.base import ToolInterface

log = logging.getLogger(__name__)


def process_action_selection(
    thoughts: str,
    action_client: Any,
    action_prompt: Any,
    tools: dict[str, ToolInterface],
) -> ActionSelection:
    """Select the next action based on generated thoughts.

    Args:
        thoughts: The thoughts generated by the think() method, representing the agent's
                  analysis of the current situation and potential next steps.
        action_client: The LLM client responsible for generating the action selection.
                       This client must support the call() method with prompt and parser.
        action_prompt: The prompt template used to guide the LLM in selecting an action.
                       It should include placeholders for tools, analysis, and format instructions.
        tools: A dictionary mapping tool names to their respective ToolInterface implementations.
               This is used to list available tools in the prompt.

    Returns:
        An ActionSelection object representing the chosen action. The object contains:
        - action_type: The type of action (e.g., "tool", "plan", "ask", "stop").
        - action_name: The name of the tool or action to execute.
        - reasoning: A string explaining the rationale for the selected action.
        - confidence: A float between 0 and 1 indicating the agent's confidence in the selection.

    Notes:
        1. The function begins by logging the start of the process with the provided thoughts.
        2. It creates a PydanticOutputParser to ensure structured output from the LLM.
        3. It constructs a list of available tool names from the provided tools dictionary.
        4. It formats the action prompt using the available tools, generated thoughts, and format instructions.
        5. It calls the action_client with the formatted prompt and parser to generate an action.
        6. If the response contains a "parsed" field, it uses that as the action selection.
        7. Otherwise, it attempts to parse the response text using parse_json_markdown.
        8. If parsing fails, it falls back to a default web search action with a confidence of 0.5.
        9. The function logs the completion and returns the final action selection.

    """
    _msg = f"process_action_selection starting with thoughts: {thoughts}"
    log.debug(_msg)

    # Create output parser for ActionSelection
    parser = PydanticOutputParser(pydantic_object=ActionSelection)
    format_instructions = parser.get_format_instructions()

    # Get list of available tools
    tool_names = list(tools.keys())

    # Generate action selection using the action LLM
    prompt = action_prompt.format(
        tools=", ".join(tool_names),
        analysis=thoughts,
        format_instructions=format_instructions,
    )

    action = None
    try:
        response = action_client.call(prompt, parser)

        # Handle LLM response format which may contain 'content', 'parsed', 'metadata' fields
        if isinstance(response, dict):
            # If response has a 'parsed' field, use that directly
            if "parsed" in response and response["parsed"] is not None:
                if isinstance(response["parsed"], ActionSelection):
                    action = response["parsed"]
                else:
                    action = ActionSelection(**response["parsed"])
            # If response has a 'content' field, parse that
            elif "content" in response:
                # First try to parse as JSON, then fallback to parser
                try:
                    parsed_data = parse_json_markdown(response["content"])
                    action = ActionSelection(**parsed_data)
                except Exception:
                    action = parser.parse(response["content"])
            # Otherwise try to create ActionSelection directly from the dict
            else:
                action = ActionSelection(**response)
        elif hasattr(response, "parsed") and response.parsed is not None:
            if isinstance(response.parsed, ActionSelection):
                action = response.parsed
            else:
                action = ActionSelection(**response.parsed)
        elif hasattr(response, "content"):
            # First try to parse as JSON, then fallback to parser
            try:
                parsed_data = parse_json_markdown(response.content)
                action = ActionSelection(**parsed_data)
            except Exception:
                action = parser.parse(response.content)
        elif isinstance(response, ActionSelection):
            action = response
        else:
            # Try to parse as string
            try:
                parsed_data = parse_json_markdown(str(response))
                action = ActionSelection(**parsed_data)
            except Exception:
                action = parser.parse(str(response))

    except Exception as e:
        _msg = f"Error in action selection, using fallback: {e}"
        log.exception(_msg)
        # Fallback action if LLM fails
        action = ActionSelection(
            action_type="tool",
            action_name="web_search",
            reasoning=f"Error in LLM action selection: {str(e)}",
            confidence=0.5,
        )

    # Ensure we always return an ActionSelection object
    if action is None:
        _msg = "Action selection is None, using default fallback"
        log.warning(_msg)
        action = ActionSelection(
            action_type="tool",
            action_name="web_search",
            reasoning="No action selected, using default web search",
            confidence=0.5,
        )

    _msg = "process_action_selection returning"
    log.debug(_msg)
    return action
