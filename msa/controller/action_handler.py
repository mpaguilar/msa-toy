"""Action handler for the multi-step agent controller."""

import logging
from typing import Any

from langchain.output_parsers import PydanticOutputParser
from langchain_core.utils.json import parse_json_markdown

from msa.controller.models import ActionSelection
from msa.tools.base import ToolInterface

log = logging.getLogger(__name__)


def process_action_selection(
    thoughts: str,
    action_client: Any,
    action_prompt: Any,
    tools: dict[str, ToolInterface],
) -> ActionSelection:
    """Select the next action based on generated thoughts.

    Args:
        thoughts: The thoughts generated by the think() method, representing the agent's
                  analysis of the current situation and potential next steps.
        action_client: The LLM client responsible for generating the action selection.
                       This client must support the call() method with prompt and parser.
        action_prompt: The prompt template used to guide the LLM in selecting an action.
                       It should include placeholders for tools, analysis, and format instructions.
        tools: A dictionary mapping tool names to their respective ToolInterface implementations.
               This is used to list available tools in the prompt.

    Returns:
        An ActionSelection object representing the chosen action. The object contains:
        - action_type: The type of action (e.g., "tool", "plan", "ask", "stop").
        - action_name: The name of the tool or action to execute.
        - reasoning: A string explaining the rationale for the selected action.
        - confidence: A float between 0 and 1 indicating the agent's confidence in the selection.

    Notes:
        1. Create a PydanticOutputParser to ensure structured output from the LLM.
        2. Extract the list of available tool names from the provided tools dictionary.
        3. Format the action prompt using the available tools, generated thoughts, and format instructions.
        4. Call the action_client with the formatted prompt and parser to generate an action.
        5. Handle various response formats from the LLM (dict with 'parsed', 'content', or direct response).
        6. Attempt to parse the response content using parse_json_markdown or the Pydantic parser.
        7. Validate the action_type to ensure it's one of the supported types.
        8. Validate the action_name to ensure it's a valid tool if the action_type is "tool".
        9. Validate the confidence value to ensure it's within the range [0.0, 1.0].
        10. If validation fails or parsing fails, use a fallback action with web_search and confidence 0.5.
        11. If the action is still None after all attempts, use a default fallback action.
        12. Network access: The action_client.call() method performs a network request to an LLM endpoint.
        13. Disk access: The parsing logic may involve temporary memory operations but not direct disk access.
    """
    _msg = f"process_action_selection starting with thoughts: {thoughts}"
    log.debug(_msg)

    # Create output parser for ActionSelection
    parser = PydanticOutputParser(pydantic_object=ActionSelection)
    format_instructions = parser.get_format_instructions()

    # Get list of available tools
    tool_names = list(tools.keys())

    # Generate action selection using the action LLM
    prompt = action_prompt.format(
        tools=", ".join(tool_names),
        analysis=thoughts,
        format_instructions=format_instructions,
    )

    action = None
    try:
        response = action_client.call(prompt, parser)

        # Handle LLM response format which may contain 'content', 'parsed', 'metadata' fields
        if isinstance(response, dict):
            # If response has a 'parsed' field, use that directly
            if "parsed" in response and response["parsed"] is not None:
                if isinstance(response["parsed"], ActionSelection):
                    action = response["parsed"]
                else:
                    action = ActionSelection(**response["parsed"])
            # If response has a 'content' field, parse that
            elif "content" in response:
                # First try to parse as JSON, then fallback to parser
                try:
                    parsed_data = parse_json_markdown(response["content"])
                    if isinstance(parsed_data, dict) and parsed_data:
                        action = ActionSelection(**parsed_data)
                    else:
                        raise ValueError("No valid JSON data found")
                except Exception:
                    try:
                        action = parser.parse(response["content"])
                    except Exception as parse_error:
                        _msg = f"Parser failed to parse content: {parse_error}"
                        log.warning(_msg)
                        raise
            # Otherwise try to create ActionSelection directly from the dict
            else:
                action = ActionSelection(**response)
        elif hasattr(response, "parsed") and response.parsed is not None:
            if isinstance(response.parsed, ActionSelection):
                action = response.parsed
            else:
                action = ActionSelection(**response.parsed)
        elif hasattr(response, "content"):
            # First try to parse as JSON, then fallback to parser
            try:
                parsed_data = parse_json_markdown(response.content)
                if isinstance(parsed_data, dict) and parsed_data:
                    action = ActionSelection(**parsed_data)
                else:
                    raise ValueError("No valid JSON data found")
            except Exception:
                try:
                    action = parser.parse(response.content)
                except Exception as parse_error:
                    _msg = f"Parser failed to parse content: {parse_error}"
                    log.warning(_msg)
                    raise
        elif isinstance(response, ActionSelection):
            action = response
        else:
            # Try to parse as string
            try:
                parsed_data = parse_json_markdown(str(response))
                if isinstance(parsed_data, dict) and parsed_data:
                    action = ActionSelection(**parsed_data)
                else:
                    raise ValueError("No valid JSON data found")
            except Exception:
                try:
                    action = parser.parse(str(response))
                except Exception as parse_error:
                    _msg = f"Parser failed to parse response: {parse_error}"
                    log.warning(_msg)
                    raise

        # Validate the action and apply fallbacks if needed
        if action is not None:
            # Check if action_type is valid
            valid_action_types = {"tool", "plan", "ask", "stop"}
            if action.action_type not in valid_action_types:
                _msg = f"Invalid action_type '{action.action_type}', using fallback"
                log.warning(_msg)
                action = ActionSelection(
                    action_type="tool",
                    action_name=action.action_name if action.action_name in tools else "web_search",
                    reasoning=f"Invalid action type '{action.action_type}', using fallback. Original reasoning: {action.reasoning}",
                    confidence=0.5,
                )
            
            # Check if action_name is valid (only for tool actions)
            if action.action_type == "tool" and action.action_name not in tools:
                _msg = f"Invalid action_name '{action.action_name}', using fallback"
                log.warning(_msg)
                action = ActionSelection(
                    action_type="tool",
                    action_name="web_search",
                    reasoning=f"Invalid tool '{action.action_name}', using web_search instead. Original reasoning: {action.reasoning}",
                    confidence=0.5,
                )
            
            # Check if confidence is valid
            if not (0.0 <= action.confidence <= 1.0):
                _msg = f"Invalid confidence '{action.confidence}', using fallback"
                log.warning(_msg)
                action = ActionSelection(
                    action_type="tool",
                    action_name=action.action_name,
                    reasoning=f"Invalid confidence '{action.confidence}', using 0.5 instead. Original reasoning: {action.reasoning}",
                    confidence=0.5,
                )

    except Exception as e:
        _msg = f"Error in action selection, using fallback: {e}"
        log.exception(_msg)
        # Fallback action if LLM fails
        action = ActionSelection(
            action_type="tool",
            action_name="web_search",
            reasoning=f"Error in LLM action selection: {str(e)}",
            confidence=0.5,
        )

    # Ensure we always return an ActionSelection object
    if action is None:
        _msg = "Action selection is None, using default fallback"
        log.warning(_msg)
        action = ActionSelection(
            action_type="tool",
            action_name="web_search",
            reasoning="No action selected, using default web search",
            confidence=0.5,
        )

    _msg = "process_action_selection returning"
    log.debug(_msg)
    return action
